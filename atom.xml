<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quinn的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://quinnyoung.com/"/>
  <updated>2020-08-19T07:59:30.306Z</updated>
  <id>https://quinnyoung.com/</id>
  
  <author>
    <name>QuinnYoung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 53 Maximum Subarray</title>
    <link href="https://quinnyoung.com/2020/08/14/leetcode-53-Maximum-Subarray/"/>
    <id>https://quinnyoung.com/2020/08/14/leetcode-53-Maximum-Subarray/</id>
    <published>2020-08-14T11:36:21.000Z</published>
    <updated>2020-08-19T07:59:30.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-53-Maximum-Subarray-最大子序和"><a href="#leetcode-53-Maximum-Subarray-最大子序和" class="headerlink" title="leetcode 53 Maximum Subarray 最大子序和"></a>leetcode 53 Maximum Subarray 最大子序和</h1><h2 id="蛮力枚举法"><a href="#蛮力枚举法" class="headerlink" title="蛮力枚举法"></a>蛮力枚举法</h2><p>很容易想到的一个算法，就是逐一枚举出所有子列和进行比较，找出最大值，其代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">size</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                sum += nums[k];</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，蛮力枚举法的时间复杂度是O(n<sup>3</sup>)，显然并不是一个实用的算法。</p><h2 id="优化枚举法"><a href="#优化枚举法" class="headerlink" title="优化枚举法"></a>优化枚举法</h2><p>注意观察蛮力枚举法的过程，我们发现其中[i…j]的子序列和，完全可以由[i…j-1]的结果再累加nums[j]求出，没必要再从头计算。于是有了改进的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">size</span>; ++j) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化枚举法的时间复杂度是O(n<sup>2</sup>)，仍然不是一个最快的算法。</p><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>基本思想就是将原问题拆分为若干子问题，分别解决后再将结果合而治之，多用递归调用的形式实现</p><ol><li><p>将[𝟏. . 𝒏]序列分为[𝟏. . 𝒏/𝟐]和[𝒏/𝟐 + 𝟏. . ] </p></li><li><p>递归求解子问题 </p><p>序列[𝟏. . 𝒏/𝟐] 的最大子序和 s<sub>1</sub></p><p>序列[𝒏/𝟐 + 𝟏. . 𝒏] 的最大子序和s<sub>2</sub></p><p>跨中点的最大子序列和 s<sub>3</sub></p></li><li><p>合并子问题的解，得到s<sub>max</sub> = 𝒎𝒂𝒙{  s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>}</p></li></ol><p>代码实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> divide_conquer(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide_conquer</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">long</span> left, <span class="keyword">long</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = divide_conquer(nums, left, mid);</span><br><span class="line">    <span class="keyword">int</span> right_max = divide_conquer(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> crossing_middle_max = crossing_middle_sub_max(nums, left, mid, right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(left_max, right_max), crossing_middle_max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">crossing_middle_sub_max</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">long</span> left, <span class="keyword">long</span> mid, <span class="keyword">long</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_sum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> right_sum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        left_sum = <span class="built_in">max</span>(sum, left_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = mid+<span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        right_sum = <span class="built_in">max</span>(sum, right_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left_sum + right_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其递归式为T(N) = 2 T(N/2) + O(N)，由递归树或主定理很容易求得其时间复杂度为T(N) = O(NLogN)。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这是一个经典的动态规划问题。假如以𝑫[𝒊]定义为以𝑿[𝒊]开头的最大子数组和，则可以建立一个递推公式：</p><p>$$<br>\begin{equation}<br>D[i] = \begin{cases}<br>X[i] + D[i+1], &amp; \text{if } D[i + 1] &gt; 0; \<br>X[i], &amp; \text{if } D[i + 1] &lt;= 0.<br>\end{cases}<br>\end{equation}<br>$$<br>其中𝑹𝒆𝒄[𝒊]为最大子数组结尾位置。下面针对一个算法实例，画表模拟推算过程：</p><table><thead><tr><th align="center">i</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">X[i]</td><td align="center">-2</td><td align="center">1</td><td align="center">-3</td><td align="center">4</td><td align="center">-1</td><td align="center">2</td><td align="center">1</td><td align="center">-5</td><td align="center">4</td></tr></tbody></table><table><thead><tr><th align="center">i</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">D[i]</td><td align="center">2</td><td align="center">4</td><td align="center">3</td><td align="center">6</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">-1</td><td align="center">4</td></tr></tbody></table><table><thead><tr><th align="center">i</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">Rec[i]</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">9</td><td align="center">9</td></tr></tbody></table><p>则连续子数组 [4,-1,2,1] 的和最大，最优解为6，子列起始位置为4，终止位置为7。</p><p>下面是其代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="built_in">size</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rec</span><span class="params">(<span class="built_in">size</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        d[<span class="built_in">size</span> - <span class="number">1</span>] = nums[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">        rec[<span class="built_in">size</span> - <span class="number">1</span>] = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = d[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                d[i] = d[i + <span class="number">1</span>] + nums[i];</span><br><span class="line">                rec[i] = rec[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                d[i] = nums[i];</span><br><span class="line">                rec[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt; max_sum) &#123;</span><br><span class="line">                max_sum = d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找子数组左右边界</span></span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_sum == d[i]) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">                r = rec[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很显然时间复杂度是O(n)的，该实现中附加了寻找子数列左右边界的过程，其实可以省去。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有关最大子序列的问题，讨论的过程总算是告一段落，下次将讨论动态规划的其他问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;leetcode-53-Maximum-Subarray-最大子序和&quot;&gt;&lt;a href=&quot;#leetcode-53-Maximum-Subarray-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;leetcode 53 Maximum Suba
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://quinnyoung.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://quinnyoung.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>网页卡顿，可能是DNS的问题？</title>
    <link href="https://quinnyoung.com/2020/07/30/%E7%BD%91%E9%A1%B5%E5%8D%A1%E9%A1%BF%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%98%AFDNS%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://quinnyoung.com/2020/07/30/%E7%BD%91%E9%A1%B5%E5%8D%A1%E9%A1%BF%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%98%AFDNS%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-30T14:23:58.000Z</published>
    <updated>2020-07-30T15:47:38.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网页卡顿，可能是DNS的问题？"><a href="#网页卡顿，可能是DNS的问题？" class="headerlink" title="网页卡顿，可能是DNS的问题？"></a>网页卡顿，可能是DNS的问题？</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近一段时间，一直忙于复习和刷题中，但某一天，突然发现leetcode中国和bilibili网页无比的卡顿。第一反应是中国电信又给宽带加了限制吗，再加上现在也不是晚上的高峰期呀，为什么？反复重启光猫和路由器，可问题并没有得到解决。</p><p>后来的某一天，也许是无独有偶，突然发现网络设置中dns默认是8.8.8.8，难道是它的问题吗？尝试性的换成114.114.114.144，发现困扰的卡顿问题居然解决了，今天决定把思考的前后过程整理一下。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>首先，我们知道，DNS是一个分层的DNS服务器实现的分布式数据库，它进行着主机名到IP地址转换的服务。</p><p>要想用户主机能够将一个HTTP请求发送到B站的web服务器，该用户必须知道其IP地址，而获取的过程大致如下:</p><blockquote><ol><li>用户主机上运行着DNS客户端</li><li>浏览器从URL中获取主机名<a href="http://www.bilibili.com，并将其传给主机上运行的DNS应用客户端" target="_blank" rel="noopener">www.bilibili.com，并将其传给主机上运行的DNS应用客户端</a></li><li>DNS客户端向DNS服务器发送一个包含主机名的请求</li><li>DNS客户会收到 一份回答报文，其中含有对应于该主机名的IP地址</li><li>一旦浏览器收到DNS的响应IP地址，它就向该IP地址的80或者443端口的HTTP服务器进程发起一个TCP连接</li></ol></blockquote><p>但由于8.8.8.8是位于国外google的DNS服务器，获取DNS报文的时延肯定要比国内邻近的DNS服务器响应时延要长，且不考虑UDP来回过墙时的丢包问题和负载分配的造成的响应服务器IP的地域随机性。不要怀疑，以下情况是真实存在的，哎！</p><p><img src="/images/image-bilibilidns.png" alt="image-bilibilidns"></p><h2 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h2><p>这是一个简单的网络问题，但最近发生了很多事，还是难免产生些感慨；不在其位不谋其事，也只能这样安慰自己了！也许我们无法改变社会，可能自己也会被改变，但请保持初心，踟蹰前行！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网页卡顿，可能是DNS的问题？&quot;&gt;&lt;a href=&quot;#网页卡顿，可能是DNS的问题？&quot; class=&quot;headerlink&quot; title=&quot;网页卡顿，可能是DNS的问题？&quot;&gt;&lt;/a&gt;网页卡顿，可能是DNS的问题？&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://quinnyoung.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="网络" scheme="https://quinnyoung.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode224 Basic Calculator</title>
    <link href="https://quinnyoung.com/2020/07/24/leetcode224-Basic-Calculator/"/>
    <id>https://quinnyoung.com/2020/07/24/leetcode224-Basic-Calculator/</id>
    <published>2020-07-23T16:45:21.000Z</published>
    <updated>2020-08-15T16:00:14.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-224-基本计算器"><a href="#Leetcode-224-基本计算器" class="headerlink" title="Leetcode 224.基本计算器"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">Leetcode 224</a>.基本计算器</h1><p><img src="/images/leetcode224.png" alt="leetcode224"></p><p>很明显，这是一个中缀表达式求值的问题，但该题也有其独特性，也诞生出了一些新的解决方法，本人大致尝试了三种方法：</p><h2 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h2><p>一开始面对此题，很容易想到的是通常解决此类栈及表达式问题的思路。</p><p>前提是只有加减运算，即省去了运算符号优先级的比较。定义两个栈，num_stack用于存储数据，op_stack用于存储操作符。</p><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><ol><li><p>从左往右扫描字符串，遇到操作数入数据栈;</p></li><li><p>若遇到操作符 + 或 - 时：</p><p>​    若操作符栈为空，直接压入该操作符栈；</p><p>​    若栈不为空，且栈顶不为左括号，则从数据栈弹出两个元素，从操作符栈弹出一个操作符进行计算，将结果并压入数据栈，然后压入该操作符栈；</p><p>​    若栈顶为左括号，压入该操作符栈；</p></li><li><p>若是左括号，直接压入操作符栈，继续扫描；</p></li><li><p>若遇到的是右括号，则从数据栈弹出两个元素，从操作弹出一个操作符进行计算，并将结果加入到数据栈中，直到栈顶为左括号，弹出左括号后，继续扫描；</p></li><li><p>扫描完成时，若操作符栈为空，则数据栈顶即为计算结果；若操作符不为空，进行一步计算后，结束。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compute</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;number_stack, <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; &amp;operator_stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num2 = number_stack.top();</span><br><span class="line">        number_stack.pop();</span><br><span class="line">        <span class="keyword">int</span> num1 = number_stack.top();</span><br><span class="line">        number_stack.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (operator_stack.top() == <span class="string">'+'</span>) &#123;</span><br><span class="line">            result = num1 + num2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = num1 - num2;</span><br><span class="line">        &#125;</span><br><span class="line">        number_stack.push(result);</span><br><span class="line">        operator_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; number_stack;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; operator_stack;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (operator_stack.empty() || operator_stack.top() == <span class="string">'('</span>) &#123;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        compute(number_stack, operator_stack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operator_stack.push(s[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    operator_stack.push(s[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (operator_stack.top() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        compute(number_stack, operator_stack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operator_stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                        num = s[i] - <span class="string">'0'</span>;</span><br><span class="line">                        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; <span class="built_in">isdigit</span>(s[i+<span class="number">1</span>])) &#123;</span><br><span class="line">                            ++i;</span><br><span class="line">                            num = s[i] - <span class="string">'0'</span> + num * <span class="number">10</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        number_stack.push(num);</span><br><span class="line">                        num = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!operator_stack.empty()) &#123;</span><br><span class="line">            compute(number_stack, operator_stack);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> number_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="变通的解法"><a href="#变通的解法" class="headerlink" title="变通的解法"></a>变通的解法</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">逆波兰表达式</a>，即后序表达式，其求值的问题也在<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">leetcdoe 150</a>讨论过；而中序表达式转换为后序表达式可以通过<a href="https://zh.wikipedia.org/wiki/Shunting_yard算法" target="_blank" rel="noopener">Shunting yard算法</a>实现，所以该基本计算器的求解就分为两个相对比较容易的子问题了，其算法过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">vector</span> = shunting_yard_algorithm(s);</span><br><span class="line">        <span class="keyword">return</span> evalRPN(<span class="built_in">vector</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 后序表达式求值 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num_stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> &amp;curr = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="string">"+"</span> || curr == <span class="string">"-"</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num2 = num_stack.top();</span><br><span class="line">                num_stack.pop();</span><br><span class="line">                <span class="keyword">int</span> num1 = num_stack.top();</span><br><span class="line">                num_stack.pop();</span><br><span class="line">                <span class="keyword">int</span> sum;</span><br><span class="line">                <span class="keyword">if</span> (curr == <span class="string">"-"</span>) &#123;</span><br><span class="line">                    sum = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sum = num1 + num2;</span><br><span class="line">                &#125;</span><br><span class="line">                num_stack.push(sum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num = stoi(curr);</span><br><span class="line">                num_stack.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 中序表达式转为后序表达式</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">shunting_yard_algorithm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_vec;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; operator_stack;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (!operator_stack.empty() &amp;&amp; (operator_stack.top() == <span class="string">'+'</span> || operator_stack.top() == <span class="string">'-'</span>)) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">string</span> op;</span><br><span class="line">                        op += operator_stack.top();</span><br><span class="line">                        operator_stack.pop();</span><br><span class="line">                        </span><br><span class="line">                        str_vec.push_back(op);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operator_stack.push(s[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    operator_stack.push(s[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (operator_stack.top() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        <span class="built_in">string</span> op;</span><br><span class="line">                        op += operator_stack.top();</span><br><span class="line">                        operator_stack.pop();</span><br><span class="line">                        </span><br><span class="line">                        str_vec.push_back(op);</span><br><span class="line">                    &#125;</span><br><span class="line">                    operator_stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                        <span class="built_in">string</span> num_str;</span><br><span class="line">                        num_str += s[i];</span><br><span class="line">                        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; <span class="built_in">isdigit</span>(s[i + <span class="number">1</span>])) &#123;</span><br><span class="line">                            ++i;</span><br><span class="line">                            num_str += s[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                        str_vec.push_back(num_str);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!operator_stack.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> op;</span><br><span class="line">            op += operator_stack.top();</span><br><span class="line">            operator_stack.pop();</span><br><span class="line">            </span><br><span class="line">            str_vec.push_back(op);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="巧妙的解法"><a href="#巧妙的解法" class="headerlink" title="巧妙的解法"></a>巧妙的解法</h2><p>leetcode中国官方关于基本计算器也提出了比较巧妙的<a href="https://leetcode-cn.com/problems/basic-calculator/solution/ji-ben-ji-suan-qi-by-leetcode/" target="_blank" rel="noopener">解题思路</a>，选择了其第二种进行说明。</p><h3 id="算法：-1"><a href="#算法：-1" class="headerlink" title="算法："></a>算法：</h3><ol><li><p>从左到右扫描字符串；</p></li><li><p>遇到 + 或 - 运算符时，首先将表达式求值到左边，然后将正负符号保存到下一次求值。</p></li><li><p>如果字符是左括号 (，将迄今为止计算的结果和符号添加到栈上，然后重新开始进行计算，就像计算一个新的表达式一样。</p></li><li><p>如果字符是右括号 )，则首先计算左侧的表达式。则产生的结果就是刚刚结束的子表达式的结果。如果栈顶部有符号，则将此结果与符号相乘。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; calculate_stack;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    result += sign * num;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    sign = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    result += sign * num;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    sign = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    calculate_stack.push(result);</span><br><span class="line">                    calculate_stack.push(sign);</span><br><span class="line">                    </span><br><span class="line">                    result = <span class="number">0</span>;</span><br><span class="line">                    sign = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    result += sign * num; <span class="comment">// ')'括号左边的值</span></span><br><span class="line">                    </span><br><span class="line">                    result *= calculate_stack.top(); <span class="comment">// '('括号前的符号</span></span><br><span class="line">                    calculate_stack.pop();</span><br><span class="line">                    </span><br><span class="line">                    result += calculate_stack.top(); <span class="comment">// 之前的计算结果</span></span><br><span class="line">                    calculate_stack.pop();</span><br><span class="line">                    </span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                        num = c - <span class="string">'0'</span> + num * <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result + (sign * num); <span class="comment">// last number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-224-基本计算器&quot;&gt;&lt;a href=&quot;#Leetcode-224-基本计算器&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 224.基本计算器&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/pr
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://quinnyoung.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://quinnyoung.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>七月最近感言</title>
    <link href="https://quinnyoung.com/2020/07/20/%E4%B8%83%E6%9C%88%E6%84%9F%E8%A8%80/"/>
    <id>https://quinnyoung.com/2020/07/20/%E4%B8%83%E6%9C%88%E6%84%9F%E8%A8%80/</id>
    <published>2020-07-19T17:18:59.000Z</published>
    <updated>2020-07-20T06:05:25.863Z</updated>
    
    <content type="html"><![CDATA[<p>在大学的时候，我就一直有一个想法是写博客，但由于个人惫懒，计划就搁浅到了如今。</p><p>去年年底，从上一家公司离职后，又碰上了武汉疫情的爆发，本来准备年后就去武汉的计划也被拖延。不过值得庆幸的是，在一月下旬的时候，终于是把驾照拿到了。回想学车的那几个月，练车前后的艰辛，教练的辱骂，还有安全员的刁难等，其中的种种心累，不足一一道哉。感觉自从大学的象牙塔出来，就马上进入互联网公司，在广州白白呆了三年，还是与这个社会格格不入。果然，成长的过程还是要付出代价。</p><p>近来，在leetcode上也陆陆续续刷了30道题，各类计算机相关的基础及教程也在复习中；故而想到了搭建个人博客，记下学习路上及生活中的点滴。愿下半年的找工作过程一路顺利，虽砥砺前行，却能乘风破浪。</p><p>此文的结尾，用我最喜欢的一句名言作结：乾坤未定，你我仍是黑马！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在大学的时候，我就一直有一个想法是写博客，但由于个人惫懒，计划就搁浅到了如今。&lt;/p&gt;
&lt;p&gt;去年年底，从上一家公司离职后，又碰上了武汉疫情的爆发，本来准备年后就去武汉的计划也被拖延。不过值得庆幸的是，在一月下旬的时候，终于是把驾照拿到了。回想学车的那几个月，练车前后的艰辛
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://quinnyoung.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="job" scheme="https://quinnyoung.com/tags/job/"/>
    
  </entry>
  
</feed>
